"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4093],{414:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var r=t(4848),o=t(8453);const s={},i="Memory",a={id:"memory",title:"Memory",description:"The primary purpose of the memory module is to store the information that is required to maintain the context of the conversation.",source:"@site/docs/memory.md",sourceDirName:".",slug:"/memory",permalink:"/TaskWeaver/docs/memory",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/TaskWeaver/tree/main/website/docs/memory.md",tags:[],version:"current",frontMatter:{},sidebar:"documentSidebar",previous:{title:"Code Execution",permalink:"/TaskWeaver/docs/code_execution"},next:{title:"FAQ",permalink:"/TaskWeaver/docs/FAQ"}},h={},d=[{value:"Role-wise Conversation History",id:"role-wise-conversation-history",level:2},{value:"Shared Memory",id:"shared-memory",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"memory",children:"Memory"})}),"\n",(0,r.jsxs)(n.p,{children:["The primary purpose of the ",(0,r.jsx)(n.code,{children:"memory"})," module is to store the information that is required to maintain the context of the conversation.\nYou can find the implementation code in ",(0,r.jsx)(n.code,{children:"taskweaver/memory/memory.py"}),".\nWe have introduced various concepts such as ",(0,r.jsx)(n.code,{children:"Round"})," and ",(0,r.jsx)(n.code,{children:"Post"})," in the ",(0,r.jsx)(n.a,{href:"concepts/",children:"concepts"})," section,\nwhich are the building blocks of the Memory module."]}),"\n",(0,r.jsx)(n.p,{children:"There are two kinds of information that are stored in the memory:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conversation History"}),": This includes the conversation that has happened so far between the user and various roles in TaskWeaver."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shared Memory"}),": This includes the information that is purposefully shared between the roles in TaskWeaver."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Let's briefly discuss the two types of information."}),"\n",(0,r.jsx)(n.h2,{id:"role-wise-conversation-history",children:"Role-wise Conversation History"}),"\n",(0,r.jsxs)(n.p,{children:["A TaskWeaver agent is composed of one or more roles. Each ",(0,r.jsx)(n.a,{href:"/TaskWeaver/docs/concepts/role",children:"role"})," have its own conversation history.\nIn TaskWeaver, we orchestrate the roles in a star topology, where the Planner is at the center and the roles are at the periphery.\nThe User only interacts with the Planner, and the Planner interacts with the roles, making planning and instructing other roles to carry out the tasks,\nas shown in the figure below."]}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD\n    User --\x3e Planner\n    Planner --\x3e Role1\n    Role1 --\x3e Planner\n    Planner --\x3e Role2\n    Role2 --\x3e Planner\n    Planner --\x3e Role3\n    Role3 --\x3e Planner\n    Planner --\x3e User"}),"\n",(0,r.jsx)(n.p,{children:'Though this fixed orchestration is a limitation, it reserves the independence of the roles. Each role does not need to know about the other roles, even their existence. For any peripheral role, the Planner is the only point of contact, i.e., its real "User",\nand it only focuses on its own expertise. It is the Planner\'s responsibility to leverage multiple roles\nfor complex tasks and orchestrate them to achieve the goal.'}),"\n",(0,r.jsx)(n.p,{children:"The conversation history of each role is stored in the memory. When a role needs to prepare a response, it can refer to the conversation history\nto understand the context of the conversation. Specifically, this typically is the process of preparing a prompt for the LLM, containing all\nthe previous chat rounds and the current request. A role only cares about the Posts sent or received by itself."}),"\n",(0,r.jsx)(n.h2,{id:"shared-memory",children:"Shared Memory"}),"\n",(0,r.jsx)(n.p,{children:"While we want to maintain the independence of the roles, there are cases where the roles need to share information.\nOne common case is about information sharing between two peripheral roles. For example, the Planner may ask the Code Interpreter to generate code\nbased on the guide provided by a Data Scientist role. In this case, the Planner needs to share the guide with the Code Interpreter.\nIn theory, this can be done by the Planner repeating the guide to the Code Interpreter, shown in the figure below."}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD\n    User --1--\x3e Planner\n    Planner --2--\x3e DataScientist\n    DataScientist --3--\x3e Planner\n    Planner --4--\x3e CodeInterpreter\n    CodeInterpreter --5--\x3e Planner\n    Planner --6--\x3e User"}),"\n",(0,r.jsx)(n.p,{children:"However, we found that the Planner can fail to repeat the guide accurately, leading to miscommunication."}),"\n",(0,r.jsxs)(n.p,{children:['Another use case is a role needing to store some control state that is shared among all roles. For example, the agent needs to handle multiple types\nof tasks. The "type" of the current user request is only determined by one role (e.g., namely ',(0,r.jsx)(n.code,{children:"TypeDeterminer"}),"), but all other roles need to know the type to prepare the response.\nIn this case, the role that determines the type can store the type in the shared memory, and other roles can refer to the shared memory to get the type."]}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD\n    User --1--\x3e Planner\n    Planner --2--\x3e TypeDeterminer\n    TypeDeterminer --3--\x3e Planner\n    TypeDeterminer --3--\x3e SharedMemory\n    SharedMemory --4--\x3e Worker1\n    SharedMemory --6--\x3e Worker2\n    Planner --4--\x3e Worker1\n    Worker1 --5--\x3e Planner\n    Planner --6--\x3e Worker2\n    Worker2 --7--\x3e Planner\n    Planner --8--\x3e User"}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"The number in the arrows indicates the order of the information flow."})}),"\n",(0,r.jsxs)(n.p,{children:["For the aforementioned reasons, we introduced the concept of Shared Memory. The Shared Memory is a special ",(0,r.jsx)(n.a,{href:"/TaskWeaver/docs/concepts/attachment",children:"Attachment"})," that is appended to the\npost of the role who wants to share information.\nThe attachment has a instance of SharedMemoryEntry in the ",(0,r.jsx)(n.code,{children:"extra"})," field. The SharedMemoryEntry has the following fields:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class SharedMemoryEntry:\n    type: Literal[...] # The type of the shared memory entry\n    content: str # The content of the shared information\n    scope: Literal["round", "conversation"] # The scope of the shared information\n    id: str # The id of the shared memory entry\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Understanding the ",(0,r.jsx)(n.code,{children:"scope"})," field is crucial to understand the Shared Memory. The ",(0,r.jsx)(n.code,{children:"scope"})," field determines the scope of the shared information.\nIf the ",(0,r.jsx)(n.code,{children:"scope"})," is ",(0,r.jsx)(n.code,{children:"round"}),", the shared information is only effective for the current round.\nOtherwise, if the ",(0,r.jsx)(n.code,{children:"scope"})," is ",(0,r.jsx)(n.code,{children:"conversation"}),", the shared information is effective for the whole conversation."]}),"\n",(0,r.jsx)(n.p,{children:"One question may be why we do not store the shared information in a separate data structure, instead of the Attachment in Posts.\nThe reason is that, if a Round fails, we need to remove the shared information within that Round as well.\nBy storing the shared information in the Attachment, as a part of the Post, we can easily filter out the shared information based on the Round status.\nThis is similar with designing the logging system of database operations in a transaction."}),"\n",(0,r.jsxs)(n.p,{children:["The consumer of the shared information can use ",(0,r.jsx)(n.code,{children:"type"})," to retrieve the shared memory entries that is effective for the current chat round,\nincluding the conversational ones. However, if one role has multiple shared memory entries with the same ",(0,r.jsx)(n.code,{children:"type"}),",\nonly the latest one is effective. In other words, later shared memory entries overwrite the previous ones with the same ",(0,r.jsx)(n.code,{children:"type"})," from the same role."]}),"\n",(0,r.jsxs)(n.p,{children:["A reference implementation of the Shared Memory is provided in the ",(0,r.jsx)(n.code,{children:"taskweaver/planner/planner.py"}),",\nwhere the Planner role shares the details of the plan with other roles."]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);